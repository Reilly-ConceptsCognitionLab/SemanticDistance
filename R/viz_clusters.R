#' viz_clusters
#'
#' @name viz_clusters
#' @param distmat a square matrix of cosine dist values (not a distance matrix!) generated by 'dist_matrix' function
#' @param type quoted argument 'dendrogram' is default, 'network' is alternative
#' @importFrom ape as.phylo
#' @importFrom dendextend set
#' @importFrom dendextend raise.dendrogram
#' @importFrom graphics par
#' @importFrom igraph set_vertex_attr
#' @importFrom igraph set_edge_attr
#' @importFrom igraph as.igraph
#' @importFrom igraph V
#' @importFrom stats order.dendrogram
#' @importFrom stats cutree
#' @importFrom stats dist
#' @importFrom stats hclust
#' @importFrom stats quantile
#' @importFrom stats as.dendrogram
#' @importFrom wesanderson wes_palette
#' @return a plot of a dendrogram
#' @export viz_clusters

viz_clusters <- function(distmat, type = 'dendrogram') {
  # Load required packages
  my_packages <- c("dendextend", "stats", "wesanderson", "igraph", "ape")
  for (pkg in my_packages) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      install.packages(pkg)
    }
    library(pkg, character.only = TRUE)
  }

  # Validate input
  if (!is.matrix(distmat) && !is.data.frame(distmat)) {
    stop("Input must be a matrix or data frame")
  }

  # Compute distance matrix
  dist_matrix <- stats::dist(distmat, method = 'euclidean')

  # Determine optimal K
  K <- eval_kmeans_clustersize(distmat)

  # Hierarchical clustering
  hc <- tryCatch(
    stats::hclust(dist_matrix, method = "ward.D2"),
    error = function(e) stop("Hierarchical clustering failed: ", e$message)
  )

  # Get colors from Moonrise3 palette
  mycols <- wesanderson::wes_palette("Moonrise3", K, type = "continuous")

  # Handle different output types
  if (type == 'dendrogram') {
    # Create dendrogram
    dend <- tryCatch(
      stats::as.dendrogram(hc),
      error = function(e) stop("Dendrogram creation failed: ", e$message)
    )

    # Validate dendrogram
    if (!inherits(dend, "dendrogram")) stop("Invalid dendrogram object")

    # Get cluster assignments FIRST
    clusters <- if (K == 1) rep(1, nrow(distmat)) else stats::cutree(hc, k = K)

    # Format and plot dendrogram - fix coloring by using clusters
    myplot <- dend %>%
      dendextend::set("labels_cex", 1.25) %>%
      dendextend::set("branches_lwd", 1.5) %>%
      dendextend::set("branches_k_color", k = K, value = mycols) %>%
      dendextend::set("leaves_pch", 19) %>%  # Add point markers
      dendextend::set("leaves_cex", 1.4) %>%
      dendextend::set("leaves_col", mycols[clusters][order.dendrogram(dend)]) %>% # Fix leaf colors
      dendextend::raise.dendrogram(2)

    plot(myplot, horiz = FALSE, type = "triangle")

    return(invisible(structure(dend, k_clusters = clusters)))
  }
  else if (type == 'network') {
    # Convert to igraph
    g <- tryCatch({
      # Get leaf nodes only (no internal nodes)
      leaf_order <- hc$order
      n_leaves <- length(leaf_order)

      # Create adjacency matrix for leaves only
      adj_matrix <- as.matrix(dist_matrix)
      adj_matrix <- adj_matrix[leaf_order, leaf_order]
      diag(adj_matrix) <- 0  # Remove self-loops

      # Create graph from adjacency matrix
      net <- igraph::graph_from_adjacency_matrix(adj_matrix,
                                                 mode = "undirected",
                                                 weighted = TRUE)

      # Get cluster assignments
      clusters <- if (K == 1) rep(1, n_leaves) else stats::cutree(hc, k = K)

      # Ensure colors match number of leaves
      vertex_colors <- mycols[clusters]

      # Get row names for labels
      node_labels <- if (!is.null(rownames(distmat))) {
        rownames(distmat)[leaf_order]
      } else {
        paste0("Node ", seq_len(n_leaves))
      }

      # Set graph attributes
      net %>%
        igraph::set_vertex_attr("cluster", value = clusters) %>%
        igraph::set_vertex_attr("color", value = vertex_colors) %>%
        igraph::set_edge_attr("color", value = "gray70") %>%
        igraph::set_vertex_attr("size", value = 12) %>%
        igraph::set_vertex_attr("label", value = node_labels) %>%
        igraph::set_vertex_attr("label.color", value = "black") %>%
        igraph::set_vertex_attr("label.cex", value = 0.8) %>%
        igraph::set_edge_attr("width", value = 1.5) %>%
        igraph::delete_edges(which(igraph::E(net)$weight < quantile(igraph::E(net)$weight, 0.5)))
    }, error = function(e) stop("Network conversion failed: ", e$message))

      # Plot with larger size and labels
      par(mar = c(1, 1, 1, 1))
      plot(g,
           layout = layout_with_fr(g),
           vertex.frame.color = "white",
           main = "Cluster Network",
           margin = -0.15,
           vertex.label.dist = 0.5)

      return(g)
  }
  else {
    stop("Invalid type parameter. Choose 'dendrogram' or 'network'")
  }
}
