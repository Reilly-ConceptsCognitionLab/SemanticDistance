---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%")
```

<img src="man/figures/header4readme.png" alt="semantic relations between cat, dog, leash" width="45%" />
<br/>

<!-- badges: start -->
[![R-CMD-check](https://github.com/Reilly-ConceptsCognitionLab/SemanticDistance/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/Reilly-ConceptsCognitionLab/SemanticDistance/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

## Before Starting
SemanticDistance nominally requires a dataframe with at least one column variable and one row of text. The package is capable of processing many more dataframe formats (e.g., word pairs arrayed in columns, conversation transcripts, unordered word lists). SemanticDistance will retain all of your original metadata after splitting/unlisting your text into a one-word-per-row structure. This sequential structure is ideal for joining distance values to timestamps and other variables as language unfolds (e.g., reaction time, pupil diameter).

## Install & Load
Install the development version of SemanticDistance from [GitHub](https://github.com/) using devtools.
```{r, message=FALSE}
#install.packages("devtools")
#devtools::install_github("Reilly-ConceptsCognitionLab/SemanticDistance")
library(SemanticDistance)
```

## Data Compatibility
Sometimes you care about computing time-ordered semantic distances between words in running discourse sampples. Other times word order doesn't matter (e.g., using a simple machine learning algorithm to cluster a bag of words by similarity). Sometimes your data will be structured as monologues (e.g., stories, narratives). Other times you might be interested in computing semantic distance turn-by-turn across speakers in a conversation transcript (i.e., dialogue). The SemanticDistance pockage can handle all of these scenarios. However, is is important that **you** understand the structure of your data and what the distance measures mean.<br/>

Here are the formats SemanticDistance can currently handle: <br/>
1. **Monologues**: A monologue transcript consists of any ordered text sample NOT delineated by a talker/speaker (e.g., stories, narratives). The minimal requirement for a monologue is one row and one column with some text in it.<br/>
2. **Dialogues**: A dialogue transcript includes any sample split by talker/speaker/interlocutor information including conversation transcripts. The minimum requirment is two cells with interlocutor identity and text.<br/>
3. **Word Pairs in Columns**: A dataframe that contains two columns of paired string data (col1 vs. col2). Calculates distance between each word pair across columns (e.g., Dog-Leash). <br/>
4. **Unordered Word Lists**: A dataframe with an unordered list of words (nominally one column, all text in one row) that will be transformed into a distance matrix and hierarchically clustered <br/>

## Sample language transcripts embedded in the package 
SemanticDistance contains some sample language transcripts that will automatically load when you call the package. These can be helpful for evaluating and debugging your own own data.<br/>

1. **Monologue_Structured:** Dataframe 1-word per row already split no missing observations <br/>
2. **Monologue_Dirty:** Dataframe text arrayed in one column 'mytext', missing observations, junk, multiword phrases contains metadata (simulated timestamps <br/>
3. **Monologue_VerbalFluency:** Dataframe ordered simulated semantic fluency data switching between categories every ten words (animals, tools, musical instruments, fruits)
4. **Dialogue_Structured:** Dataframe simulating 'perfect' conversation transcript, one word per turn, two talkers
5. **Dialogue_Dirty:** Dataframe simulating 'dirty' conversation transcript, multiple lines per person, lots of stopwords, missing obervations, stray transcription symbols <br/>
6. **WordPairs_Columns:** Dataframe with word pairs arrayed in two columns <br/>
7. **WordList_TestClustering:** Unordered unsplit word list, some junk and also animal and weapon terms for  hierachical clustering analysis <br/>
<br>

# <span style="color: darkred;">---Step 1: Cleaning--- </span>
First identify the type of data structure you want to process (e.g., monologue, dialogue, unordered list). The semantic distance functions work by indexing unique numeric identifiers. You **MUST** first clean/prep your raw text to append these identifers. Prepare your lexical data for computing pairwise semantic distances by first doing the following: <br/>
1) Read your data into R. Label your text and metadata columns however you like. <br/>
2) Your dataframe should contain at least one column with the target string data (e.g., mytext). <br/>
3) Identify the format of your sample (e.g., monologue, dialogue, columns, unstructured). <br/>
4) Decide on your cleaning parameters (lemmatize, omit stopwords, omit punctuation). <br/>
5) Run the approproate cleaning function specifying the parameters that best fit your data and aims. <br/>
<br/>

## <span style="color: brown;">1.1 Clean Monologue Transcript (clean_monologue)</span>
Clean a monologue transcript by calling the 'clean_monologue' function. Specific arguments include: <br/>

**df** = raw dataframe with at least one column of text <br/>
**wordcol** = quoted variable column name where your target text lives (e.g., 'mytext') <br/>
**clean** = applies cleaning functions (e.g., punct out, lowercase, etc); default is TRUE <br/>
**omit_stops** = omits stopwords, default is TRUE <br/>
**lemmatize** = transforms raw word to lemmatized form, default is TRUE <br/>

Output of 'clean_monologue' on a messy monologue transcript
```{r}
#text in this dataframe is in a column 'mytext'
MyCleanMonologue1 <- clean_monologue(Monologue_Dirty, 'mytext', clean=T, omit_stops=T)
head(MyCleanMonologue1, n=10)
```

Output of 'clean_monologue' on a structured monologue transcript
```{r}
#text in this dataframe is in a column 'mytext'
MyCleanMonologue2 <- clean_monologue(Monologue_Structured, 'mytext', clean=T)
head(MyCleanMonologue2, n=10)
```
<br/>

## <span style="color: brown;">1.2 Clean Dialogue Transcripts (clean_dialogue)</span>
This could be a conversation transcript or any language sample where you care about talker/interlocutor information (e.g., computing semantic distance across turns in a conversation). Your dataframe should nominally contain a text column and a speaker/talker column. Arguments clean_dialogue are: <br/>
**df** = your raw dataframe with at least one column of text AND a talker column <br/>
**wordcol** = column name (quoted) containing the text you want cleaned <br/>
**whotalks** = column name (quoted) containing the talker ID (will convert to factor) <br/>
**clean** = T/F (default is T) applies cleaning functions <br/>
**omit_stops** = T/F omits stopwords, default is TRUE <br/>
**lemmatize** = T/F transforms raw word to lemmatized form, default is TRUE <br/>

Output of 'clean_dialogue' prepping a well-structured dialogue transcript
```{r}
My_CleanDialogue1 <- clean_dialogue(Dialogue_Structured, "mytext", "speaker", omit_stops=T, lemmatize=T)
head(My_CleanDialogue1, n=8)
```
<br/>

## <span style="color: brown;">1.3 Clean Word Pairs Arrayed in Columns (clean_2columns)</span>
SemanticDistance also computes pairwise distance for data arrayed in columns. Run the function, the cleaned columns will appear in the dataframe. Arguments to the 'clean_monologue' function call are: <br/>

**df** = your raw dataframe with at least one column of text <br/>
**word1** = quoted variable reflecting the column name where your first word lives <br/>
**word2** = quoted variable reflecting the column name where your first word lives <br/>
**clean** = T/F (default is T) applies cleaning functions <br/>
**omit_stops** = T/F omits stopwords, default is TRUE <br/>
**lemmatize** = T/F transforms raw word to lemmatized form, default is TRUE <br/>

Output of 'clean_2columns' word pairs arrayed in columns
```{r}
MyClean2Columns <- clean_2cols(WordPairs_Columns, 'word1', 'word2', clean=T, omit_stops=T, lemmatize=T)
head(MyClean2Columns, n=8) #view head cleaned data
```
<br/>

## <span style="color: brown;">1.4 Clean Unordered Word List (clean_unordered4matrix)</span>
This cleaning option is used for prepping a vector of words for hierarchical clustering. Word order is no longer a factor since all words will be shuffled. This cleaning function retains only one instance of a word (no duplicates). Arguments to the 'clean_unordered4matrix' function call are: <br/>

**df** = your raw dataframe with at least one column of text <br/>
**wordcol** = quoted variable reflecting where your text lives <br/>
**clean** = T/F (default is T) applies cleaning functions <br/>
**omit_stops** = T/F omits stopwords, default is TRUE <br/>
**lemmatize** = T/F transforms raw word to lemmatized form, default is TRUE <br/>

Output of 'clean_unordered4matrix' on unordered word list
```{r}
#Run clean fn 
MyCleanDat4Matrix <- clean_unordered4matrix(WordList_TestClustering, wordcol="mytext", clean=TRUE, omit_stops=TRUE, lemmatize=TRUE) 
head(MyCleanDat4Matrix)
```
<br/>
<br/>

# <span style="color: darkred;">--Step 2: Compute Semantic Distance--</span>
SemanticDistance will append cosine distance values between each pair of elements specified by the user (e.g., word-to-word, ngram-to-word). These distance values are derived from two large lookup databases in the package with fixed semantic vectors for >70k English words. CosDist_Glo reflects cosine distance between vectors derived from training a GLOVE word embedding model (300 hyperparameters per word). CodDist_SD15 refects cosine distance between two chunks (words, groups of words) characterized across 15 meaningful perceptual and affective dimensions (e.g., color, sound, valence). <br/>
<br>

## <span style="color: brown;">2.1: Compute Ngram-to-Word Distance (dist_ngram2word)</span>
Computes cosine distance for two models (embedding and experiential) using a rolling ngram approach consisting of groups of words (ngrams) to the next word. *IMPORTANT* the way this works is that the function rolls backward from the target word skipping over NAs until filling the desired ngram size. It does not do the same procedure for filling forward. If you evaluate a row with an NA it will look backward until finding n real words and then produce an NA when trying to compare the ngram to the target word (because there is no target word for that row).

<img src="man/figures/RollingNgramIllustrate.png" alt="illustrates how rolling ngrams work on a vector of words by moving a window and contrasting each chunk to each new word" width="50%" /> <br/>
<br/>

Remember to call a cleaned/prepped dataframe! Arguments to 'dist_ngram2word' are: <br/>
| **dat** dataframe of a monologue transcript cleaned and prepped with clean_monologue fn <br/>
| **ngram** window size preceding each new content word <br/>

Output 'dist_ngram2word' on a messy monologue
```{r}
#Set the ngram=1, distance every word to the next word
#MyNgram2WordDists1 <- dist_ngram2word(MyCleanMonologue1, ngram=1) #distance word-to-word
#head(MyNgram2WordDists1, n=8)
```

Output 'dist_ngram2word' on a well-structured monologue
```{r}
#Set the ngram=3, distance rolling chunks of 3 words to the next word
#MyNgram2WordDists2 <- dist_ngram2word(MyCleanMonologue2, ngram=3) #distance word-to-word
#head(MyNgram2WordDists2, n=12)
```
<br/>

## <span style="color: brown;">2.2: Compute Ngram-to-Ngram Distance (dist_ngram2ngram)</span>
User specifies n-gram size (e.g., ngram=2). Distance computed from each two-word chunk to the next iterating all the way down the dataframe until there are no more words to 'fill out' the last ngram. <br/>

<img src="man/figures/Ngram2Ngram_Dist.png" alt="semantic distance is derived from chunk to chunk groupings of words" width="50%"/> <br/>

Arguments to dist_ngram2ngram are: <br/>
| dat = dataframe w/ a monologue sample cleaned and prepped <br/>
| ngram = chunk size (chunk-to-chunk) <br/>

Output 'dist_ngram2ngram' on monologue transcript
```{r}
#Give the function a cleaned monologue transcript, This example involves chunks of 2-words to 2-words
MyNgram2NgramDists <- dist_ngram2ngram(MyCleanMonologue2, ngram=2)
head(MyNgram2NgramDists, n=8)
```
<br/>

## <span style="color: brown;">2.3: Compute Turn-by-Turn Distance (dist_dialogue_turns)</span>
Averages the semantic vectors for all content words in a turn. Computes the cosine distance to the average of the semantic vectors of the content words in the subsequent turn. <br/>

Arguments to 'dist_dialogue_turns' are: <br/>
**dat** = dataframe w/ a dialogue sample cleaned and prepped using 'clean_dialogue' fn<br/>

Output of 'dist_dialogue_turns' turn-to-turn distance on sample dialogue transcript
```{r}
#MyDialogueDists <- dist_dialogue_turns(MyCleanDialogue)
#head(MyDialogueDists, n=15)
```
<br/>

## <span style="color: brown;">2.4: Compute Distances Between Word Pairs in Columns (dist_2cols)</span>
When your data are arrayed in two columns and you are interested in computing pairwise distance across the columns. The only critical argument is your dataframe name. Remember to pass a cleaned dataframe (even if you disable stopwords and lemmatization). Arguments to the function: <br/>
| dat = your cleaned dataframe with two paired columns of text <br/>

Arguments to 'dist_2cols' are: <br/>
**dat** = dataframe w/ word pairs arrayed in columns cleaned and prepped using 'clean_2cols' fn<br/>

Output of 'dist_2cols' on 2-column arrayed dataframe
```{r}
#MyDistsColumns <- dist_2cols(MyClean2Columns) #only argument is dataframe
#head(MyDistsColumns, n=8)
```
<br/>

## <span style="color: brown;">2.5: Distance Fixed Cluster of Words to each new word (anchor_dist)</span>
Models semantic distance from each successive new word in a language sample to the average of the semantic vectors for the first block of N content words in that sample. This anchored distance provides a metric of overall semantic drift as a language sample unfolds relative to a fixed starting point.<br/>

Arguments to 'anchor_dist' are: <br/>
**dat** = dataframe w/ a monologue sample cleaned and prepped using 'clean_monologue' fn<br/>
**anchor_size** = size of the initial chunk of words for chunk-to-new-word comparisons fn<br/>

<img src="man/figures/Anchor_2Word_Dist.png" alt="illustrates distance from each new word of a language sample to an initial chunk of n-words" width="80%" />

Output of 'anchor_dist' on a sample monologue transcript
```{r}
MyDistsAnchored <- dist_anchor(MyCleanMonologue2, anchor_size=8)
head(MyDistsAnchored, n=10)
```
<br/>

### <span style="color: brown;">2.6: Distance Matrix All Word Pairs (dist_matrix_all)</span>
Returns square matrix where each entry [i,j] is the cosine distance between word i and word j. Matrix contains original words as both row and column names for reference. User specifies whether to return a matrix based on embeddings (GLOVE) or experiential norms (SD15). Input a unordered vector of words cleaned/prepped with 'clean_unordered4matrix' function <br/>

Arguments to 'dist_matrix_all' are: <br/>
**dat** = dataframe cleaned and prepped using 'clean_unordered4matrix' fn<br/>
**dist_type** = quoted argument default is 'embedding', other option is "SD15" fn<br/>

Output of 'dist_unordered' on unordered word list
```{r}
MyDistMatrix <- dist_matrix_all(MyCleanDat4Matrix)
head(MyDistMatrix)
```
<br/>
<br/>

# <span style="color: darkred;">---Step 3: Data Visualization Options---</span>
## Monologue Time Series: ngram2word
Plots id_orig (as x-axis time) by distance measure (facetted GLO and SD15). Add red line annotation if semantic distance jump is z>3 based on the distribution of that time series
```{r}
#Select id_orig, "CosDist_Glo", "CosDist_SD15", pivot_longer
#add smoothing options
#Argument annotate=T, adds red line whenever semantic distance jump is z>3
#linear interpolation using zoo, necessary for geom_path to complete
#pivots on any/all cos_dist columns
#facets on any/all cos_dist columns
#scale axis 0 to 1.5
```

## Monologue Time Series: anchor2word
```{r}
#TBA
```


## Time series plot for dialogues
Color point by talker
```{r}
#TBA
```


#Animate Time Series
```{r}
#TBA
```



